# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TA3XIoV3S49mz40ZkJXHFVwCgVw0VHKF
"""



import torch
import torch.nn as nn
# import torch.nn.functional as F
# # import torchvision.transforms as transforms
# # import torchvision.models as models
# import torch.optim as optim
# import numpy as np

# from abcdataset import get_h5_images
# from abcdataset import ABCDataset
# from visualization import ShowBandsCombination, plot_spatial, scatter_spectrums,plot_spectrum, scatter_spectrum
# from abctrain import validate_conv_deconv, validate_model, train_conv_deconv, train_predict



"""### models

"""

class ConvEncoder(nn.Module):
  """ create convolutional layers to extract features
  from input multipe spectral images
  
  Attributes:
  data : input data to be encoded
  """

  def __init__(self, in_channel):
      super(ConvEncoder,self).__init__()
      #Convolution 1
      self.conv1=nn.Conv2d(in_channels=in_channel,out_channels=128, kernel_size=7, stride=2, padding = 3)   # padding='valid', there's no padding; padding='same' the input are zero-padded
      # nn.init.xavier_uniform(self.conv2.weight)

      #Convolution 2
      self.conv2 = nn.Conv2d(in_channels=128, out_channels=128, kernel_size=1, padding='same')
      
      #Convolution 3
      self.conv3 = nn.Conv2d(in_channels=128, out_channels=128, kernel_size=3, padding='same')
      self.bn3 = nn.BatchNorm2d(128)

      #Convolution 4      
      self.conv4 = nn.Conv2d(in_channels=128, out_channels=256, kernel_size=1, padding='same')
      self.bn4 = nn.BatchNorm2d(256)

      #Convolution 5      
      self.conv5 = nn.Conv2d(in_channels=512, out_channels=512, kernel_size=1, padding='same')
      self.bn4 = nn.BatchNorm2d(512)

      # activation function
      self.relu= nn.ReLU()

      #Max Pool 1
      self.maxpool = nn.MaxPool2d(kernel_size=2,return_indices=True)

      #Average Pool 1
      # self.averagepool = nn.AvgPool2d(kernel_size=2,return_indices=True)
      # self.maxpool1= nn.MaxPool2d(kernel_size=2,return_indices=True)

  def forward(self,x):

      pool_info = []

      out=self.relu(self.conv1(x))
      # out=self.relu(self.conv2(out))
      # out=self.bn3(out)

      size1 = out.size()
      out,indices1=self.maxpool(out)
      pool_info.append([indices1,size1])

      out=self.relu(self.conv3(out))
      out=self.relu(self.conv4(out))
      # out=self.bn4(out)
      
      size2 = out.size()
      out,indices2=self.maxpool(out)
      pool_info.append([indices2,size2])

      # out=self.conv5(out)

      return(out, pool_info)

class DeConvDecoder(nn.Module):
  """ 
  reconstruct image from extracted features
  
  Attributes:
  features : input data to be encoded
  in_channel: reconstructed channels
  """
  def __init__(self, in_channel):
      super(DeConvDecoder,self).__init__()

      #De Convolution 1
      self.deconv1=nn.ConvTranspose2d(in_channels=512, out_channels=512, kernel_size=1)
      # nn.init.xavier_uniform(self.deconv1.weight)
      # self.swish4=nn.ReLU()
      self.bn1 = nn.BatchNorm2d(512)

      #De Convolution 2
      self.deconv2=nn.ConvTranspose2d(in_channels=256,out_channels=128,kernel_size=1)
      self.bn2 = nn.BatchNorm2d(256)

      #De Convolution 3
      self.deconv3=nn.ConvTranspose2d(in_channels=128,out_channels=128,kernel_size=3, padding = 1)
      self.bn3 = nn.BatchNorm2d(128)

      #De Convolution 4
      self.deconv4=nn.ConvTranspose2d(in_channels=128,out_channels=128,kernel_size=1)
      self.bn4 = nn.BatchNorm2d(128)

      #DeConvolution 5
      self.deconv5=nn.ConvTranspose2d(in_channels=128,out_channels=in_channel,kernel_size=7, stride=2, padding = 3)
      # nn.init.xavier_uniform(self.deconv3.weight)
      # self.swish6=nn.ReLU()

      # activation function
      self.relu= nn.ReLU()

      #Max UnPool 1
      self.maxunpool=nn.MaxUnpool2d(kernel_size=2)
      #Max UnPool 2
      # self.maxunpool2=nn.MaxUnpool2d(kernel_size=2)


  def forward(self,x, pool_info):

      # out=self.relu(self.deconv1(x))

      indices2,size2 = pool_info[1]
      # out=self.maxunpool(x)
      out=self.maxunpool(x,indices2,size2)

      out=self.relu(self.deconv2(out))
      out=self.relu(self.deconv3(out))
      # out=self.bn3(out)

      indices1,size1 = pool_info[0]
      # out=self.maxunpool(out)
      out=self.maxunpool(out,indices1,size1)
      
      # out=self.relu(self.deconv4(out))
      out=self.deconv5(out)
      # out=self.swish6(out)

      return(out)

class myNet(nn.Module):
    def __init__(self, in_channel):
        super().__init__()
        #self.conv1 = nn.Conv2d(in_channel, kernel_size=7, stride=2, padding=3, bias=False)
        self.conv1 = nn.Conv2d(in_channel,64, kernel_size=5, stride=1, padding=0, bias=False)
        self.conv2 = nn.Conv2d(64,128, kernel_size=5, stride=1, padding=0, bias=False)
        self.conv3 = nn.Conv2d(128,256, kernel_size=3, stride=1, padding=0, bias=False)
        self.pool = nn.MaxPool2d(2, 2)
        self.bn2 = nn.BatchNorm2d(128)
        self.bn3 = nn.BatchNorm2d(256)
        self.fc1 = nn.Linear(256*7*7, 4098)
        self.fc2 = nn.Linear(4098, 1028)
        self.fc3 = nn.Linear(1028, 1)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = F.relu(self.conv2(x))
        x = self.bn3(F.relu(self.conv3(x)))
        x = torch.flatten(x, 1) # flatten all dimensions except batch
        # print(x.size())
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x

class EncoderDecoder(nn.Module):
    """ create convolutional layers to extract features
    from input multipe spectral images
    
    Attributes:
    data : input data to be encoded
    """

    def __init__(self, in_channel):
        super(EncoderDecoder,self).__init__()
        #Convolution 1
        self.conv1=nn.Conv2d(in_channels=in_channel,out_channels=64, kernel_size=4,stride=1, padding=0)
        # nn.init.xavier_uniform(self.conv1.weight)
        self.relu= nn.ReLU()

        #Max Pool 1
        # self.maxpool= nn.MaxPool2d(kernel_size=2,return_indices=True)

        #Convolution 2
        self.conv2 = nn.Conv2d(in_channels=64, out_channels=128, kernel_size=5)

        #Convolution 3
        self.conv3 = nn.Conv2d(in_channels=128, out_channels=192, kernel_size=3)

        #De Convolution 1
        self.deconv1=nn.ConvTranspose2d(in_channels=192,out_channels=128,kernel_size=3)

        #De Convolution 2
        self.deconv2=nn.ConvTranspose2d(in_channels=128,out_channels=64,kernel_size=5)
        # self.maxunpool=nn.MaxUnpool2d(kernel_size=2)

        #DeConvolution 3
        self.deconv3=nn.ConvTranspose2d(in_channels=64,out_channels=in_channel,kernel_size=4)


    def forward(self,x):
        out=self.conv1(x)
        out=self.relu(out)
        size1 = out.size()
        # out,indices1=self.maxpool1(out)
        out=self.conv2(out)
        out=self.relu(out)
        size2 = out.size()
        # out,indices2=self.maxpool2(out)
        out=self.conv3(out)
        out=self.relu(out)

        out=self.deconv1(out)
        out=self.relu(out)
        # out=self.maxunpool(out,indices2,size2)
        out=self.deconv2(out)
        out=self.relu(out)
        # out=self.maxunpool(out,indices1,size1)
        out=self.deconv3(out)
        # out=self.swish6(out)
        return(out)
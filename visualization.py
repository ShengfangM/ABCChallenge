# -*- coding: utf-8 -*-
"""visualization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a5KwR_9He3OLSb42Y8t7j6vbyK-Z16_-
"""

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d
import numpy as np
import torch

""" three functions to imshow images (images should be HWC model) 
functions also be used in the class ShowBandsCombination"""
def show_selectbands(imgi, bands, label, max_min_norm = None):
  n = len(bands)
  fig, axs = plt.subplots(1, int(np.ceil(n/3)), figsize=(n, 3))
  fig = plt.gcf()
  # fig.set_size_inches(18.5,10.5)
  fig.suptitle(str(label))
  j = 0
  for c in range(0, n, 3):
    if c+3>n-1:
      c = n-3
    img = imgi[:,:, bands[c:c+3]]
    # img = img.transpose(1, 2, 0)
    if max_min_norm is None:
      img = img/(img.max())
    else:
      [maxl, minl] = max_min_norm
      minv = min(minl[c:c+3])
      maxv = max(maxl[c:c+3])
      img = (img - minv) /(maxv - minv)

    axs[j].imshow(img)
    j += 1


def show_singleband(imgi, bands, label, grayscale = True, max_min_norm = None):
  n = len(bands)
  fig, axs = plt.subplots(1, n, figsize=(n*3, 4))
  fig = plt.gcf()
  fig.suptitle(str(label))
  # fig.set_size_inches(18.5,10.5)
  j = 0
  for c in range(0, n):
    if c > imgi.shape[0]:
      print("exceed bands")
      c = imgi.shape[0]-1
    img = imgi[:,:, bands[c]]
    # img = img.transpose(1, 2, 0)
    if max_min_norm is None:
      img = img/(img.max())
    else:
      [maxl, minl] = max_min_norm
      minv = min(minl[c])
      maxv = max(maxl[c])
      img = (img - minv) /(maxv - minv)
    
    img = img/(img.max())
    if grayscale == True:
      axs[j].imshow(img, cmap='gray')
    else:
      axs[j].imshow(img)
    j += 1


def show_3bands(imgi, bands, label, max_min_norm = None ):
  n = len(bands)
  fig, axs = plt.subplots(1, n, figsize=(n*4, 4))
  fig = plt.gcf()
  fig.suptitle(str(label), fontsize=16, y=0.95)  # adjust the y parameter to reduce the space

  # fig.set_size_inches(18.5,10.5)
  j = 0
  for subbands in bands:
    img = imgi[:, :, subbands]
    if max_min_norm is None:
      img = img/(img.max())
    else:
      [maxl, minl] = max_min_norm
      minv = min(minl[subbands])
      maxv = max(maxl[subbands])
      img = (img - minv) /(maxv - minv)
    
    axs[j].imshow(img)
    j += 1

class ShowBandsCombination():
  """ the input image should be NCHW or NCHW
  when show image, the image need to be transposef from chw to hwc
  imgi = imgi.transpose(1, 2, 0) # from chw to hwc

  labels is the description of the image

  imshow_all_3bands
  imshow_all_single
  imshow_selectBands_3bands
  imshow_selectBands_single

  """
  def __init__(self, imgs, labels, max_min_norm):
    if isinstance(imgs, torch.Tensor):
      imgs = imgs.detach().numpy()
    if len(imgs.shape) ==3:
      imgs = imgs.reshape((1, ) + imgs.shape)
    self.img = imgs
    self.labels = labels
    self.max_min_norm = max_min_norm


  def imshow_all_3bands(self):
    img_shape = self.img.shape
    n_bands = img_shape[1]
    for i in range(img_shape[0]):
      imgi = self.img[i,:]
      imgi = imgi.transpose(1, 2, 0)
      label = self.labels[i]
      bands = range(n_bands)
      # self.show_selectbands(imgi, bands, label)
      show_selectbands(imgi, bands, label, self.max_min_norm )


  def imshow_all_single(self, grayscale=True):
    img_shape = self.img.shape
    n_bands = img_shape[1]
    for i in range(img_shape[0]):
      imgi = self.img[i,:]
      imgi = imgi.transpose(1, 2, 0)
      label = self.labels[i]
      bands = range(n_bands)
      # self.show_singleband(imgi, bands, label, grayscale)
      show_singleband(imgi, bands, label, grayscale, self.max_min_norm)

  
  def imshow_selectBands_3bands(self, bands):
    """ bands is a list, must be 3 bands or one bands"""
    if bands == []: return
    else:
      img_shape = self.img.shape
      # n_channels = img_shape[1]
      band0 = bands[0]
      if type(band0) == int:
        for i in range(img_shape[0]):
          imgi = self.img[i,:]
          imgi = imgi.transpose(1, 2, 0)
          label = self.labels[i]
          # self.show_selectbands(imgi, bands, label)
          show_selectbands(imgi, bands, label, self.max_min_norm)
      else:
        for i in range(img_shape[0]):
          imgi = self.img[i,:]
          imgi = imgi.transpose(1, 2, 0)
          label = self.labels[i]
          # self.show_3bands(imgi, bands, label)
          show_3bands(imgi, bands, label, self.max_min_norm)

  
  def imshow_selectBands_single(self, bands, grayscale=True):
    """ bands is a list, must be 3 bands or one bands"""
    if bands == []: return
    else:
      img_shape = self.img.shape
      # n_channels = img_shape[1]
      for i in range(img_shape[0]):
        imgi = self.img[i,:]
        imgi = imgi.transpose(1, 2, 0)
        label = self.labels[i]
        # self.show_singleband(imgi, bands, label, grayscale)
        show_singleband(imgi, bands, label, grayscale, self.max_min_norm )
      

#  def show_selectbands(self, imgi, bands, label):
#     n = len(bands)
#     fig, axs = plt.subplots(1, int(np.ceil(n/3)), figsize=(n, 3))
#     fig = plt.gcf()
#     # fig.set_size_inches(18.5,10.5)
#     fig.suptitle(str(label))
#     j = 0
#     for c in range(0, n, 3):
#       if c+3>n-1:
#         c = n-3
#       img = imgi[bands[c:c+3],:]
#       img = img.transpose(1, 2, 0)
#       img = img/(img.max())
#       axs[j].imshow(img)
#       j += 1


#   def show_singleband(self, imgi, bands, label, grayscale):
#     n = len(bands)
#     fig, axs = plt.subplots(1, n, figsize=(n*3, 4))
#     fig = plt.gcf()
#     fig.suptitle(str(label))
#     # fig.set_size_inches(18.5,10.5)
#     j = 0
#     for c in range(0, n):
#       if c > imgi.shape[0]:
#         print("exceed bands")
#         c = imgi.shape[0]-1
#       img = imgi[bands[c],:]
#       # img = img.transpose(1, 2, 0)
#       img = img/(img.max())
#       if grayscale == True:
#         axs[j].imshow(img, cmap='gray')
#       else:
#         axs[j].imshow(img)
#       j += 1


#   def show_3bands(self, imgi, bands, label):
#     n = len(bands)
 
#     fig, axs = plt.subplots(1, n, figsize=(n*4, 4))
#     fig = plt.gcf()
#     fig.suptitle(str(label), fontsize=16, y=0.95)  # adjust the y parameter to reduce the space

#     # fig.set_size_inches(18.5,10.5)
#     j = 0
#     for subbands in bands:
#       img = imgi[subbands,:]
#       img = img.transpose(1, 2, 0)
#       img = img/(img.max())
#       axs[j].imshow(img)
#       j += 1

def plot3d_spectrum(image, label):
  """
  plot the spectrum for each pixels in the image
  image is numpy array with shape (C, H,W)
  """
  c,h,w = image.shape
  # assigning coordinates
  y = np.linspace(1, w*h, w*h)
  x = np.linspace(1, c, c)
  X, Y = np.meshgrid(x, y)
  # reshape image to fit plot
  img = image.reshape(c,-1)

  # Change the Size of Graph using Figsize
  fig = plt.figure(figsize=(10, 10))
  ax = plt.axes(projection='3d')
  # creating the visualization
  ax.plot_wireframe( X,Y, img.transpose())
  ax.set_title(f'The biomass is {label}')
  ax.set_xlabel('channels')
  ax.set_ylabel('pixels')
  ax.set_zlabel('spectrum')

def plot_spectrum(image, label):
  """
  plot the spectrum for each pixels in the image
  image is numpy array with shape (C, H,W)
  """
  c,h,w = image.shape
  # # assigning coordinates
  # y = np.linspace(1, w*h, w*h)
  # x = np.linspace(1, c, c)
  # X, Y = np.meshgrid(x, y)
  # # reshape image to fit plot
  img = image.reshape(c,-1)

  # Change the Size of Graph using Figsize
  fig = plt.figure(figsize=(6, 5))

  for i in range(w*h):
    plt.plot(range(c),img[:c,i])
  plt.title(f'The biomass is {label}')
  plt.xlabel('channels')
  plt.ylabel('intensity')
  # plt.ylim([0,6000])
  # plt.xlim([0,11])
  plt.show()



def plot_spatial(img, img_label):
  img_shape = img.shape
  if len(img_shape) ==3:
    img = img.reshape((1, ) + img_shape)
  img_shape = img.shape
  
  channels = img_shape[1]
  fig, axs = plt.subplots(channels, figsize=(10, 36), sharex=True)
  for i in range(img_shape[0]):
    imgi = img[i]
    img_labeli = img_label[i]
    for c in range(channels):
      #calculate skewness
      val_band = imgi[c].flatten()
      axs[c].plot(val_band, ".", label=str(img_labeli))
      # axs[c].legend()
      # # Add a legend outside each subplot
      legend0 = axs[c].legend(bbox_to_anchor=(1.05, 1), loc='upper left')
      axs[c].set_ylabel(f'bands {c +1}');
      # axs[c].set_title(f'the biomass is {img_labeli}')

  # legend0 = axs[channels-1].legend(bbox_to_anchor=(1.05, 1), loc='upper left')
  # Adjust the layout to make room for the legends
  plt.subplots_adjust(right=0.8)

  # # Add axis labels and a title
  # fig.suptitle(f'the biomass is {img_label}', fontsize=16)
  # fig.text(0.5, 0.04, 'x-axis label', ha='center', fontsize=14)
  # fig.text(0.04, 0.5, 'y-axis label', va='center', rotation='vertical', fontsize=14)
  plt.show()

def imshow_chw(img):
  if isinstance(img, torch.Tensor):
    img = img.detach().numpy()

  channels = img.shape[0]
  fig, axs = plt.subplots(1,4, figsize=(10, 6))
  fig = plt.gcf()
  fig.set_size_inches(18.5,10.5)
  for c in range(0,3,channels):
    if c+3>11:
      c = 11-3
    
    imgi = img[c:c+3,:]
    imgi = imgi.permute(1, 2, 0)
    imgi = imgi/(imgi.max())

    axs[c//3-1].imshow(imgi)
    plt.show()



def visual_loader(data_loader):
#test if data is correctly loaded
  img,label = next(iter(data_loader))

  for l in range(len(img)):
      
      imgi = img[l].permute(1,2,0) 
      print(imgi.size())
      #imgi = imgi[:,:,2:5]

      fig = plt.gcf()
      fig.set_size_inches(18.5,10.5)

      img_show = np.array(imgi[:,:,0:3])
      m = img_show.max()
      img_show = img_show / m

      plt.imshow(img_show)
      plt.title(label[l])

      # ax = plt.gca()

      # for i in range(len(boxes)):

      #     ax.add_patch(Rectangle((boxes[i][0],boxes[i][1]),
      #                            (boxes[i][2] - boxes[i][0]),
      #                            (boxes[i][3] - boxes[i][1]),
      #                           fill = False,
      #                           edgecolor = 'red',
      #                           linewidth=3))
      #     ax.text(boxes[i][0],boxes[i][1], 'peanut')

      # fig = plt.gcf
      # plt.tick_params(labelbottom='on')
      plt.show()
    
      # print(img[:,:,2])

def plot_biomasses(validate_biomasses1):
  plt.plot(validate_biomasses1, '.')
  plt.ylim([0,1])

# def 
# for i in range(25000):
#   arr = train_images[i,-4,:]
#   if (arr > 0).any():
#     print(i)

# import torch
# import torch.nn as nn
# import torch.nn.functional as F
# # import torchvision.transforms as transforms
# # import torchvision.models as models
# import torch.optim as optim

# import matplotlib.pyplot as plt
# import numpy as np
# from abcdataset import get_h5_images
# from abcdataset import ABCDataset
# # from visualization import ShowBandsCombination, plot_spatial

# # if __name__ == main:
# !wget -q  https://share.phys.ethz.ch/~pf/albecker/abc/09072022_1154_train.h5
# !wget -q  https://share.phys.ethz.ch/~pf/albecker/abc/09072022_1154_val.h5
# !wget -q https://share.phys.ethz.ch/~pf/albecker/abc/09072022_1154_test.h5

# # <KeysViewHDF5 ['agbd', 'cloud', 'images', 'lat', 'lon', 'scl']>
# keys = ['agbd', 'images', 'cloud', 'lat', 'lon', 'scl']
# data_type = np.float64
# cat_vi = True
# cat_cloud = True
# cat_coord = True
# cat_scl = True

# train_file = "09072022_1154_train.h5"
# validate_file = "09072022_1154_val.h5"
# test_file = "09072022_1154_test.h5"

# train_biomasses, train_images = get_h5_images(train_file, keys, data_type, cat_vi, cat_cloud, cat_coord, cat_scl)
# validate_biomasses,validate_images = get_h5_images(validate_file, keys, data_type, cat_vi, cat_cloud, cat_coord, cat_scl)
# test_biomasses,test_images = get_h5_images(test_file, keys, data_type, cat_vi, cat_cloud, cat_coord, cat_scl)

# max_train = train_images.max((0,2,3))
# min_train = train_images.min((0,2,3))



# plot3d_spectrum(train_images[1,0:12,:], train_biomasses[1])

# plot_spectrum(train_images[1,0:15,:], train_biomasses[1])

# plot_spatial(train_images[0:2,:], train_biomasses[0:2])